-- 함수(FUNCTION) : 컬럼의 값을 읽어서 계산한 결과 리턴
-- 단일행 함수(SINGLE ROW FUNCTION) : 컬럼에 기록된 N개의 값을 읽어서 N개의 결과를 리턴
-- 그룹 함수(GROUP FUNCTION) : 컬럼에 기록된 N개의 값을 읽어서 1개의 결과 리턴

-- SELECT절에 단일 행 함수와 그룹 함수를 함께 사용 못 함 : 결과 행의 개수가 다르기 때문

-- 함수 사용 가능 위치 : SELECT절, WHERE절, GROUP BY절, HAVING절, ORDER BY절


-- 단일 행 함수
-- 1. 문자 관련 함수
-- LENGTH : 글자 수 반환 / LENGTHB : 글자의 바이트 사이즈 반환
SELECT LENGTH('오라클'), LENGTHB('오라클') -- 한글 3Byte
FROM DUAL; -- 가상 테이블

SELECT LENGTH('ABCD'), LENGTHB('ABCD')
FROM DUAL;

SELECT LENGTH(EMAIL), LENGTHB(EMAIL)
FROM EMPLOYEE;

-- INSTR : 해당 문자열의 위치 -- Zero-Index기반 아님
SELECT INSTR('AABAACAABBAA', 'B') FROM DUAL;
SELECT INSTR('AABAACAABBAA', 'C') FROM DUAL;
SELECT INSTR('AABAACAABBAA', 'Z') FROM DUAL;

SELECT INSTR('AABAACAABBAA', 'B', 1) FROM DUAL; -- 1부터 읽기 시작해서 처음으로 나오는 B의 위치 반환
SELECT INSTR('AABAACAABBAA', 'B', -1) FROM DUAL; -- -1(끝)부터 읽기 시작해서 처음으로 나오는 B의 위치 반환
SELECT INSTR('AABAACAABBAA', 'C', -1) FROM DUAL;
SELECT INSTR('AABAACAABBAA', 'B', 1, 2) FROM DUAL; -- 1부터 읽기 시작해서 두 번째로 나오는 B의 위치 반환
SELECT INSTR('AABAACAABBAA', 'B', -1, 2) FROM DUAL;
SELECT INSTR('AABAACAABBAA', 'C', 1, 2) FROM DUAL;

-- EMPLOYEE테이블에서 이메일의 @위치 반환
SELECT EMP_NAME, EMAIL, INSTR(EMAIL, '@')
FROM EMPLOYEE;

-- LPAD / RPAD
SELECT LPAD(EMAIL, 20)
FROM EMPLOYEE;

SELECT LPAD(EMAIL, 20, '#')
FROM EMPLOYEE;

SELECT RPAD(EMAIL, 20)
FROM EMPLOYEE;

SELECT RPAD(EMAIL, 20, '#')
FROM EMPLOYEE;

-- LOWER / UPPER / INITCAP
-- LOWER : 소문자로 변경
-- UPPER : 대문자로 변경
-- INITCAP : 단어의 첫글자를 대문자로 변환
SELECT LOWER('Welcome To My World') FROM DUAL;
SELECT UPPER('Welcome To My World') FROM DUAL;
SELECT INITCAP('welcome to my world') FROM DUAL;

-- CONCAT : 전달받은 문자열이나 컬럼을 하나로 합친 후 반환
SELECT CONCAT('가나다라', 'ABCD') FROM DUAL;
SELECT '가나다라' || 'ABCD' FROM DUAL;

-- LTRIM / RTRIM :  문자열 혹은 컬럼의 왼쪽/오른쪽에서 지정한 "STR에 포함되어 있는 모든 문자 제거"
SELECT EMP_NAME,  PHONE, LTRIM(PHONE, '010'), EMAIL, RTRIM(EMAIL, '@kh.or.kr')
FROM EMPLOYEE;

SELECT LTRIM('   KH') FROM DUAL;
SELECT LTRIM('   KH', ' ') FROM DUAL;
SELECT LTRIM('000123456' , '0') FROM DUAL;
SELECT LTRIM('123123KH', '123') FROM DUAL;

SELECT RTRIM('KH   ') A FROM DUAL;
SELECT RTRIM('123456000', '0') FROM DUAL;
SELECT RTRIM('KH24392398472' , '0123456789') FROM DUAL;

-- TRIM : 문자열의 앞/뒤/양쪽에 있는 문자 제거
SELECT TRIM('   KH   ') FROM DUAL;
SELECT TRIM('Z' FROM 'ZZZKHZZZ') FROM DUAL;
SELECT TRIM('1' FROM '123321KH23212') FROM DUAL;
SELECT TRIM(LEADING 'Z' FROM 'ZZZ123345ZZZ') FROM DUAL;
SELECT TRIM(TRAILING '3' FROM '33KH333333') FROM DUAL;
SELECT TRIM(BOTH '3' FROM '33KH333333') FROM DUAL;

-- SUBSTR : 컬럼이나 문자열에서 지정한 위치부터 지정한 개수의 문자열을 잘라내어 반환
SELECT SUBSTR('SHOWMETHEMONEY', 7) FROM DUAL;
SELECT SUBSTR('SHOWMETHEMONEY', 5, 2) FROM DUAL;
SELECT SUBSTR('SHOWMETHEMONEY', 5, 0) FROM DUAL;
SELECT SUBSTR('SHOWMETHEMONEY', 1, 6) FROM DUAL;
SELECT SUBSTR('SHOWMETHEMONEY', -8, 3) FROM DUAL;
SELECT SUBSTR('SHOWMETHEMONEY', -10, 2) FROM DUAL;
SELECT SUBSTR('쇼우 미 더 머니', 2, 5) FROM DUAL;

-- EMPLOYEE테이블의 이름, 이메일, @이후를 제외한 아이디 조회
SELECT EMP_NAME, EMAIL, SUBSTR(EMAIL, 1, INSTR(EMAIL, '@') - 1) ID
FROM EMPLOYEE;

-- 주민등록번호를 이용하여 남/여 판단
-- EMPLOYEE테이블에서 이름과 주민번호에서 성별을 나타내는 부분 조회
SELECT EMP_NAME, SUBSTR(EMP_NO, 8, 1)
FROM EMPLOYEE;

-- EMPLOYEE테이블에서 남자만 조회(사원 명, '남')
SELECT EMP_NAME, '남'
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) = 1;

-- EMPLOYEE테이블에서 남자만 조회(사원 명, '여')
SELECT EMP_NAME, '여'
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) = 2;

-- EMPLOYEE테이블에서 직원들의 주민번호를 이용하여 사원 명, 생년, 생월, 생일 조회
SELECT EMP_NAME, SUBSTR(EMP_NO, 1, 2) 생년, 
                 SUBSTR(EMP_NO, 3, 2) 생월, 
                 SUBSTR(EMP_NO, 5, 2) 생일 
FROM EMPLOYEE;

-- REPLACE : 컬럼의 문자 혹은 문자열에서 특정 문자열을 지정한 문자열로 바꾼 후 반환
SELECT REPLACE('서울시 강남구 역삼동', '역삼동', '삼성동') 
FROM DUAL;

SELECT REPLACE('원격 기간동안 반에 나올 수 있는 학생의 수는 15명 이하입니다.', '15명', '5명')
FROM DUAL;

-- EMPLOYEE테이블에서 이메일의 도메인을 gamil.com으로 변경
SELECT REPLACE(EMAIL, 'kh.or.kr', 'gmail.com')
FROM EMPLOYEE;

SELECT REPLACE(EMAIL, SUBSTR(EMAIL, INSTR(EMAIL, '@') + 1), 'gmail.com')
FROM EMPLOYEE;

-- EMPLOYEE테이블에서 사원 명, 주민번호 조회
-- 단, 주민번호는 생년월일만 보이게 하고 '-' 다음 값은 '*'로 변경
SELECT EMP_NAME, RPAD(SUBSTR(EMP_NO, 1, 7), LENGTH(EMP_NO), '*') 
FROM EMPLOYEE;

SELECT EMP_NAME, SUBSTR(EMP_NO, 1, 7) || '*******'
FROM EMPLOYEE;

SELECT EMP_NAME, REPLACE(EMP_NO, SUBSTR(EMP_NO, 8), '*******')
FROM EMPLOYEE;

-- 2. 숫자 관련 함수
-- ABS : 절대값을 구하여 반환하는 함수
SELECT ABS(10.9) FROM DUAL;
SELECT ABS(-10.9) FROM DUAL;
SELECT ABS(10) FROM DUAL;
SELECT ABS(-10) FROM DUAL;

-- MOD : 나머지를 구하는 함수 -- 나머지 값의 부호는 나누어진 수를 따라감
SELECT MOD(10, 3) FROM DUAL;
SELECT MOD(-10, 3) FROM DUAL;
SELECT MOD(10, -3) FROM DUAL;
SELECT MOD(10.9, 3) FROM DUAL;

-- ROUND : 반올림하여 리턴하는 함수
SELECT ROUND(123.456) FROM DUAL;
SELECT ROUND(123.789) FROM DUAL;
SELECT ROUND(123.567, 0) FROM DUAL;
SELECT ROUND(123.456, 1) FROM DUAL;
SELECT ROUND(123.456, 2) FROM DUAL;
SELECT ROUND(123.456, -2) FROM DUAL;

SELECT ROUND(-10.61) FROM DUAL;

-- FLOOR : 내림(수학적)
SELECT FLOOR(123.456) FROM DUAL;
SELECT FLOOR(123.678) FROM DUAL;

-- TRUNC : 버림(절삭)
SELECT TRUNC(123.456) FROM DUAL;
SELECT TRUNC(123.678) FROM DUAL;
SELECT TRUNC(123.456, 1) FROM DUAL;
SELECT TRUNC(123.456, 2) FROM DUAL;
SELECT TRUNC(123.456, -1) FROM DUAL;

-- CEIL : 올림
SELECT CEIL(123.456) FROM DUAL;
SELECT CEIL(123.789) FROM DUAL;

-- 3. 날짜 관련 함수
-- SYSDATE : 시스템에 저장되어 있는 날짜 반환
SELECT SYSDATE FROM DUAL;

-- MONTHS_BETWEEN : 개월 수의 차이를 숫자로 리턴
-- EMPLOYEE테이블에서 사원의 이름, 입사일, 근무 개월 수 조회
SELECT EMP_NAME, HIRE_DATE, MONTHS_BETWEEN(SYSDATE, HIRE_DATE)
FROM EMPLOYEE;

SELECT EMP_NAME, HIRE_DATE, ABS(MONTHS_BETWEEN(HIRE_DATE, SYSDATE))
FROM EMPLOYEE;

-- ADD_MONTHS : 날짜에서 숫자만큼 개월 수를 더하여 리턴
SELECT ADD_MONTHS(SYSDATE, 5) FROM DUAL;
SELECT ADD_MONTHS(SYSDATE, 3) FROM DUAL;
-- EMPLOYEE테이블에서 사원 명, 입사일, 입사 후 6개월이 된 날짜 조회
SELECT EMP_NAME, HIRE_DATE, ADD_MONTHS(HIRE_DATE, 6)
FROM EMPLOYEE;

-- LAST_DAY : 해당 달의 마지막 날짜 리턴
SELECT SYSDATE, LAST_DAY(SYSDATE) FROM DUAL;

-- NEXT_DAY : 기준 날짜에서 구하려는 요일에 가장 가까운 날짜 리턴
SELECT SYSDATE, NEXT_DAY(SYSDATE, '목요일') FROM DUAL;
SELECT SYSDATE, NEXT_DAY(SYSDATE, 5) FROM DUAL;
-- 일 월 화 수 목 금 토
-- 1  2  3  4 5  6  7
SELECT SYSDATE, NEXT_DAY(SYSDATE, '목') FROM DUAL;
SELECT SYSDATE, NEXT_DAY(SYSDATE, '수연씨는 우리 반 미소천사') FROM DUAL;
SELECT SYSDATE, NEXT_DAY(SYSDATE, '일초라도 안보이면 이렇게 초조한데 삼초는 어떻게 기다려 이야이야이야이야') FROM DUAL;
SELECT SYSDATE, NEXT_DAY(SYSDATE, 'THURSDAY') FROM DUAL;

ALTER SESSION SET NLS_LANGUAGE = AMERICAN;
SELECT SYSDATE, NEXT_DAY(SYSDATE, 'THU') FROM DUAL;
SELECT SYSDATE, NEXT_DAY(SYSDATE, 'THUOOOOOOOOOOOOO') FROM DUAL;

ALTER SESSION SET NLS_LANGUAGE = KOREAN;

------------- 실습문제----------------------------
-- 1. EMPLOYEE 테이블에서 사원명, 입사일-오늘, 오늘-입사일 조회
-- 단, 별칭은 근무일수1, 근무일수2로 하고
-- 모두 정수처리(내림), 양수가 되도록 처리
SELECT EMP_NAME, ABS(FLOOR(HIRE_DATE - SYSDATE)) 근무일수1, FLOOR(SYSDATE - HIRE_DATE) 근무일수2
FROM EMPLOYEE;

-- 2. EMPLOYEE 테이블에서 사번이 홀수인 직원들의 정보 모두 조회
SELECT *
FROM EMPLOYEE
WHERE MOD(EMP_ID, 2) = 1;

-- 3. EMPLOYEE 테이블에서 근무 년수가 20년 이상인 직원 정보 조회
-- 정확히 20년 이상
SELECT *
FROM EMPLOYEE
WHERE MONTHS_BETWEEN(SYSDATE, HIRE_DATE) / 12 >= 20;

-- 20년차 이상
SELECT *
FROM EMPLOYEE
WHERE EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE) >= 20;

-- 4. EMPLOYEE 테이블에서 사원명, 입사일, 입사한 월의 근무일수를 조회
SELECT EMP_NAME, HIRE_DATE, LAST_DAY(HIRE_DATE) - ADD_MONTHS(HIRE_DATE, 0)
FROM EMPLOYEE;

SELECT EMP_NAME, HIRE_DATE, EXTRACT(DAY FROM LAST_DAY(HIRE_DATE)) - EXTRACT(DAY FROM HIRE_DATE)
FROM EMPLOYEE;
-------------------------------------------------

-- EXTRACT : 년, 월, 일 정보를 추출하여 리턴
-- EXTRACT(YEAR FROM 날짜) : 년토 추출
-- EXTRACT(MONTH FROM 날짜) : 달 추출
-- EXTRACT(DAY FROM 날짜) : 일 추출
-- EMPLOYEE테이블에서 사원의 이름, 입사 연도, 입사 달, 입사 일 조회
SELECT EMP_NAME "이름",
        EXTRACT(YEAR FROM HIRE_DATE) "입사 연도",
        EXTRACT(MONTH FROM HIRE_DATE) "입사 달",
        EXTRACT(DAY FROM HIRE_DATE) "입사 일"
FROM EMPLOYEE
--ORDER BY EXTRACT(YEAR FROM HIRE_DATE);
--ORDER BY EMP_NAME;
--ORDER BY 4;
--ORDER BY "입사 연도";
--ORDER BY 이름;
--ORDER BY 이름 DESC;
--ORDER BY 이름 ASC;
ORDER BY "입사 연도", 이름 DESC;

-- EMPLOYEE테이블에서 사원의 이름, 입사 일, 근무 년수 조회
-- 단, 근무 년수는 현재년도 - 입사년도로 조회하세요
SELECT EMP_NAME, HIRE_DATE, EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE)
FROM EMPLOYEE;

SELECT EMP_NAME, HIRE_DATE,
        FLOOR(MONTHS_BETWEEN(SYSDATE, HIRE_DATE) / 12)
FROM EMPLOYEE;

-- 4. 형변환 함수
--TO_CHAR : 날짜/숫자 데이터를 문자 데이터 변경
SELECT TO_CHAR(1234) FROM DUAL;
SELECT TO_CHAR(1234, '99999') A FROM DUAL; -- 5칸, 오른쪽 정렬, 빈칸 공백
SELECT TO_CHAR(1234, '00000') A FROM DUAL; -- 5칸, 오른쪽 정렬 빈칸 0
SELECT TO_CHAR(1234, 'FML99999') A FROM DUAL;
SELECT TO_CHAR(1234, '$99999') A FROM DUAL;
SELECT TO_CHAR(1234, 'FM$99999') A FROM DUAL;
SELECT TO_CHAR(1234, '99,999') A FROM DUAL;
SELECT TO_CHAR(1234, 'FM99,999') A FROM DUAL;
SELECT TO_CHAR(1234, '00,000') A FROM DUAL;
SELECT TO_CHAR(1234, '999') A FROM DUAL;

-- EMPLOYEE테이블에서 사원명, 급여 조회 (급여는 '\9,000,000'형식으로 표시)
SELECT EMP_NAME, TO_CHAR(SALARY, 'FML9,999,999') 급여
FROM EMPLOYEE;

SELECT TO_CHAR(SYSDATE, 'PM HH24:MI:SS') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'AM HH:MI:SS') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'MON DY, YYYY') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD DAY') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YYYY-FMMM-DD DAY') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YEAR, Q') FROM DUAL; -- YEAR : 영어로 년도표현 Q : 분기

-- 오늘 날짜에 대해 연도 4자리, 2자리, 연도 이름 출력
SELECT TO_CHAR(SYSDATE, 'YYYY'), TO_CHAR(SYSDATE, 'YY'), TO_CHAR(SYSDATE, 'YEAR') FROM DUAL;

-- 오늘 날짜에서 월만 출력
SELECT TO_CHAR(SYSDATE, 'MM'),
       TO_CHAR(SYSDATE, 'MONTH'),
       TO_CHAR(SYSDATE, 'MON'),
       TO_CHAR(SYSDATE, 'RM')
FROM DUAL;

-- 오늘 날짜에서 일만 출력
SELECT TO_CHAR(SYSDATE, 'DDD'), -- 년
       TO_CHAR(SYSDATE, 'DD'), -- 월
       TO_CHAR(SYSDATE, 'D') -- 주
FROM DUAL;

-- EMPLOYEE테이블에서 이름, 입사일 조회
-- 입사일은 포맷 적용 : 2020년 08월 20일(목)
SELECT EMP_NAME, TO_CHAR(HIRE_DATE, 'YYYY"년" MM"월" DD"일""("DY")"')
FROM EMPLOYEE;

-- TO_DATE : 문자/숫자 데이터를 날짜 데이터로 변환
SELECT TO_DATE('20200101', 'YYYYMMDD') FROM DUAL;
SELECT TO_DATE(20200101, 'YYYYMMDD') FROM DUAL;
SELECT TO_CHAR(TO_DATE('20200101', 'YYYYMMDD'), 'YYYY, MON') FROM DUAL;
SELECT TO_CHAR(TO_DATE('210208 215000', 'YYMMDD HH24MISS'), 'YY-MM-DD PM HH:MI:SS DY') FROM DUAL;

-- RR과 YY의 차이
-- Y를 적용할 경우 두 자리 연도에 현재 세기 적용
-- R을 사용할 경우 두 자리 연도가 50 이상일 때는 이전 세기, 50 미만일 때는 현재 세기
SELECT TO_CHAR(TO_DATE('980504', 'YYMMDD'), 'YYYYMMDD') FROM DUAL; -- 20980504
SELECT TO_CHAR(TO_DATE('140915', 'YYMMDD'), 'YYYYMMDD') FROM DUAL; -- 20140915
SELECT TO_CHAR(TO_DATE('980504', 'RRMMDD'), 'YYYYMMDD') FROM DUAL; -- 19980504
SELECT TO_CHAR(TO_DATE('140915', 'RRMMDD'), 'YYYYMMDD') FROM DUAL; -- 20140915

-- EMPLOYEE테이블에서 2000년도 이후에 입사한 사원의 사번, 이름, 입사일 조회
SELECT EMP_NO, EMP_NAME, HIRE_DATE
FROM EMPLOYEE
--WHERE HIRE_DATE >= '00/01/01';
WHERE HIRE_DATE >= TO_DATE(20000101, 'RRRRMMDD');

-- TO_NUMBER : 문자 데이터를 숫자 데이터로 변환
SELECT TO_NUMBER('12345789') FROM DUAL;
SELECT '123' + '456' FROM DUAL;
SELECT '123' + '456A' FROM DUAL;
SELECT '1,000,000' + '550,000' FROM DUAL;
SELECT TO_NUMBER('1,000,000', '9,999,999') + TO_NUMBER('550,000', '999,999') FROM DUAL;

-- 5. NULL 관련 함수
SELECT SALARY * (1 + BONUS)
FROM EMPLOYEE;

-- NVL(컬럼명, 컬럼값이 NULL일때 바꿀 값)
SELECT EMP_NAME, BONUS, NVL(BONUS, 0)
FROM EMPLOYEE;

-- NVL2(컬럼 명, 바꿀 값1, 바꿀 값2)
-- 해당 컬럼의 값이 있으면 바꿀 값1로 변경, 컬럼의 값이 없으면 바꿀 값2로 변경
-- EMPLOYEE테이블에서 보너스가 NULL인 직원은 0.5로, NULL이 아닌 직원은 0.7로 변경
SELECT EMP_NAME, BONUS, NVL2(BONUS, 0.7, 0.5)
FROM EMPLOYEE;

-- NULLIF(비교대상1, 비교대상2)
-- 두 개의 값이 동일하면 NULL, 동일하지 않으면 비교대상1 반환
SELECT NULLIF(123, 123), NULLIF(123, 124) FROM DUAL;

-- 6. 선택 함수
-- DECODE(계산식|컬럼명, 조건값1, 선택값1, 조건값2, 선택값2, 조건값3, 선택값3, ...)
-- 비교하고자 하는 컬럼이나 값이 조건식과 같으면 결과 값을 반환
SELECT EMP_ID, EMP_NAME, EMP_NO, 
       DECODE(SUBSTR(EMP_NO, 8, 1), 1, '남', 2, '여') 성별
FROM EMPLOYEE;

SELECT EMP_ID, EMP_NAME, EMP_NO, 
       DECODE(SUBSTR(EMP_NO, 8, 1), 1, '남', '여') 성별
FROM EMPLOYEE;

-- 직원의 급여를 인상하고자 한다
-- 직급코드가 J7이면 급여의 10% 인상
-- 직급코드가 J6이면 급여의 15% 인상
-- 직급코드가 J5이면 급여의 20% 인상
-- 그 외 직급은 5% 인상
-- EMPLOYEE테이블에서 직원 명, 직급코드, 급여, 인상 급여 조회
SELECT EMP_NAME, JOB_CODE, SALARY, 
     DECODE(JOB_CODE, 'J7', SALARY * 1.1,
                      'J6', SALARY * 1.15,
                      'J5', SALARY * 1.2,
                      SALARY * 1.05) 인상급여
FROM EMPLOYEE;

-- CASE WHEN 조건식 THEN 결과값
--      WHEN 조건식 THEN 결과값
--      ELSE 결과값
-- END
-- 비교하고자 하는 값 또는 컬럼이 조건식과 같으면 결과 값 반환(조건은 범위 값 가능)
SELECT EMP_ID, EMP_NAME, EMP_NO,
        CASE WHEN SUBSTR(EMP_NO, 8, 1) = 1 THEN '남'
             ELSE '여'
        END
FROM EMPLOYEE;

SELECT EMP_NAME, JOB_CODE, SALARY,
        CASE WHEN JOB_CODE = 'J7' THEN SALARY * 1.1
             WHEN JOB_CODE = 'J6' THEN SALARY * 1.15
             WHEN JOB_CODE = 'J5' THEN SALARY * 1.2
             ELSE SALARY * 1.05
        END 인상급여
FROM EMPLOYEE;

SELECT EMP_ID, EMP_NAME, SALARY, 
       CASE WHEN SALARY > 5000000 THEN '1등급'
            WHEN SALARY > 3500000 THEN '2등급'
            WHEN SALARY > 2000000 THEN '3등급'
            ELSE '4등급'
       END 등급
FROM EMPLOYEE;

-- 사번, 사원명, 급여
-- 급여가 500만원 이상이면 '고급'
-- 급여가 300~500만원이면 '중급'
-- 그 이하는 '초급'으로 출력처리하고 별칭증 '구분'으로 한다.
SELECT EMP_ID, EMP_NAME, SALARY,
       CASE WHEN SALARY >= 5000000 THEN '고급'
            WHEN SALARY >= 3000000 THEN '중급'
            ELSE '초급'
       END 구분
FROM EMPLOYEE;

-- 그룹 함수
-- SUM
-- EMPLOYEE테이블에서 전 사원의 급여 총합 조회
SELECT SUM(SALARY)
FROM EMPLOYEE;

-- EMPLOYEE테이블에서 남자 사원의 급여 총합 조회
SELECT SUM(SALARY)
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) = 1;

-- EMPLOYEE테이블에서 부서코드가 D5인 직원의 보너스 포함 연봉 합계 조회
SELECT SUM(SALARY + (SALARY * NVL(BONUS, 0)) * 12)
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5';

-- AVG : 평균을 구하여 리턴
-- EMPLOYEE테이블에서 전 사원의 급여 평균 조회
SELECT AVG(SALARY)
FROM EMPLOYEE;

-- EMPLOYEE테이블에서 전 사원의 보너스 평균을 소수 셋 째자리에서 반올림한 것 조회
SELECT ROUND(AVG(NVL(BONUS, 0)), 2)
FROM EMPLOYEE;

SELECT AVG(BONUS) 기본평균, AVG(DISTINCT BONUS) 중복제거평균, AVG(NVL(BONUS, 0)) NULL이0으로바뀐평균
FROM EMPLOYEE;

-- MIN
-- EMPLOYEE테이블에서 가장 적은 급여 조회
SELECT MIN(SALARY)
FROM EMPLOYEE;

-- EMPLOYEE테이블에서 알파벳 순서가 가장 빠른 이메일, 가장 빠른 입사일 조회
SELECT MIN(EMAIL), MIN(HIRE_DATE)
FROM EMPLOYEE;

-- MAX
-- EMPLOYEE테이블에서 가장 많은 급여 조회
SELECT MAX(SALARY)
FROM EMPLOYEE;

-- EMPLOYEE테이블에서 알파벳 순서가 가장 늦은 이메일, 가장 최근 입사일 조회
SELECT MAX(EMAIL), MAX(HIRE_DATE)
FROM EMPLOYEE;

-- COUNT : 행 개수를 헤아려 리턴
-- COUNT([DISTINCT] 컬럼명) : 중복을 제거한 행 개수를 헤아려 리턴
-- COUNT(*) : NULL을 포함한 전체 행 개수 리턴
-- COUNT(컬럼 명) : NULL을 제외한 실제 값이 기록된 행 개수 리턴
-- EMPLOYEE테이블에서 전체 사원 수, 부서코드가 있는 사원 수, 사원들이 속해있는 부서의 수 조회
SELECT COUNT(*), COUNT(DEPT_CODE), COUNT(DISTINCT DEPT_CODE)
FROM EMPLOYEE;
