-- DDL : 데이터 정의 언어
-- 객체를 만들고(CREATE), 수정하고(ALTER), 삭제하는(DROP) 구문

-- CREATE : 데이터베이스 객체를 생성하는 구문
-- 테이블 생성 구문
CREATE TABLE MEMBER(
    MEMBER_ID VARCHAR2(20),
    MEMBER_PWD VARCHAR2(20),
    MEMBER_NAME VARCHAR2(20)
);

SELECT * FROM MEMBER;

-- 컬럼에 주석 달기
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '회원비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '회원이름';

DESC MEMBER;

-- 제약조건(CONSTRAINTS)
-- 테이블 작성 시 각 컬럼에 대한 값 기록에 대한 제약 조건 설정 가능
-- 데이터 무결성 : 데이터의 정확성, 일관성, 유효성이 유지되는 것
-- 입력 데이터에 문제가 없는지 자동으로 검사하는 목적
-- 제약조건은 테이블을 처음 만들 때 지정해도 되고, 테이블을 만들고 나서 지정해도 됨

-- 제약 조건 확인
DESC USER_CONSTRAINTS;
SELECT * FROM USER_CONSTRAINTS; -- 사용자가 작성한 제약조건 확인
SELECT * FROM USER_CONS_COLUMNS; -- 제약조건이 걸려있는 컬럼 확인

-- NOT NULL : 컬럼에 반드시 값이 기록되어야 하는 경우 사용
-- 삽입/수정 시 NULL값을 허용하지 않도록 컬럼레벨에서 제한
CREATE TABLE USER_NOCONST(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(20),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_NOCONST 
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');

INSERT INTO USER_NOCONST
VALUES(2, NULL, NULL, NULL, NULL, '010-1111-2222', 'kang123@kh.or.kr');

-- 제약 조건 설정하는 방법
-- 1. 테이블을 만들 때 같이 설정하기
--      1-1. 테이블 레벨에 설정
--      1-2. 컬럼 레벨에 설정
-- 2. 테이블을 만든 후 추가로 설정하기

CREATE TABLE USER_NOTNULL(
    USER_NO NUMBER NOT NULL, -- 컬럼레벨에서 제약조건 설정
    USER_ID VARCHAR2(20) NOT NULL,
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_NOTNULL 
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');

INSERT INTO USER_NOTNULL
VALUES(2, NULL, NULL, NULL, NULL, '010-1111-2222', 'kang123@kh.or.kr');
-- ORA-01400: cannot insert NULL into ("KH"."USER_NOTNULL"."USER_ID")

-- UNIQUE : 컬럼에 입력하는 값에 대해 중복을 제한하는 제약조건
-- 컬럼레벨, 테이블 레벨에서 설정 가능
SELECT * FROM USER_NOCONST;

INSERT INTO USER_NOCONST 
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');

CREATE TABLE USER_UNIQUE(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) UNIQUE, -- 컬럼 레벨에서 제약조건 설정
    USER_PWD VARCHAR2(20),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_UNIQUE
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');

INSERT INTO USER_UNIQUE
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');
-- ORA-00001: unique constraint (KH.SYS_C007032) violated

CREATE TABLE USER_UNIQUE2(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(20),
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    UNIQUE(USER_ID) -- 테이블 레벨에서 제약조건 설정
);

CREATE TABLE USER_UNIQUE3(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    UNIQUE(USER_ID, USER_NO) -- 테이블 레벨에서 제약조건 설정
);

INSERT INTO USER_UNIQUE3
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');

INSERT INTO USER_UNIQUE3
VALUES(2, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');

INSERT INTO USER_UNIQUE3
VALUES(2, 'user02', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');

INSERT INTO USER_UNIQUE3
VALUES(1, 'user02', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');

INSERT INTO USER_UNIQUE3
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');

CREATE TABLE CONS_NAME(
    TSET_DATA1 VARCHAR2(20) CONSTRAINT CN_TD1_NN NOT NULL,
    TEST_DATA2 VARCHAR2(20) CONSTRAINT CN_TD2_UQ UNIQUE,
    TEST_DATA3 VARCHAR2(30),
    CONSTRAINT CN_TD3_UK UNIQUE(TEST_DATA3)
);

INSERT INTO CONS_NAME
VALUES(NULL, 'TEST2', 'TEST3');

INSERT INTO CONS_NAME
VALUES('TEST1', 'TEST2', 'TEST3');

INSERT INTO CONS_NAME
VALUES('TEST1', 'TEST2', 'TEST3');
-- ORA-00001: unique constraint (KH.CN_TD2_UQ) violated

-- PRIMARY KET (PK, 기본키)
-- NOT NULL + UNIQUE
-- 테이블에서 한 행의 정보를 찾기 위해 사용할 컬럼 의미 : 테이블에 대한 식별자 역할
-- 한 테이블 당 한 개만 설정 가능
-- 컬럼 레벨, 테이블 레벨 둘 다 설정 가능

CREATE TABLE USER_PRIMARYKEY(
    USER_NO NUMBER CONSTRAINT UR_UN_PK PRIMARY KEY, -- 컬럼 레벨
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_PRIMARYKEY 
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');

INSERT INTO USER_PRIMARYKEY 
VALUES(1, 'user02', 'pass02', '남나눔', '남', '010-2222-3333', 'nam123@kh.or.kr');

INSERT INTO USER_PRIMARYKEY 
VALUES(NULL, 'user03', 'pass03', '도대담', '남', '010-3333-4444', 'doh123@kh.or.kr');

CREATE TABLE USER_PRIMARYKEY2(
    USER_NO NUMBER, -- 컬럼 레벨
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    CONSTRAINT UR_USERNO_PK PRIMARY KEY(USER_NO, USER_ID)
);

INSERT INTO USER_PRIMARYKEY2 
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');

INSERT INTO USER_PRIMARYKEY2 
VALUES(1, 'user02', 'pass02', '남나눔', '남', '010-2222-3333', 'nam123@kh.or.kr');

INSERT INTO USER_PRIMARYKEY2 
VALUES(2, 'user01', 'pass01', '도대담', '남', '010-3333-4444', 'doh123@kh.or.kr');

-- FOREIGN KEY(FK, 외부키/외래키)
-- 참조된 다른 테이블이 제공하는 값만 사용 가능
-- FOREIGN KEY제약조건에 의해 테이블 간의 관계 형성
-- 제공 되는 값 외에는 NULL 사용 가능

-- 컬럼 레벨에서 지정하는 경우
-- 컬럼명 자료형(크기) [CONSTRAINT 제약조건명] REPERENCES 참조하는 테이블 명 [(참조할 컬럼)] [삭제 룰]

-- 테이블 레벨에서 지정하는 경우
-- [CONSTRAINT 제약조건명] FOREIGN KEY(적용할 컬럼 명) REFERENCES 참조하는 테이블 명 [(참조할 컬럼)] [삭제 룰]
CREATE TABLE USER_GRADE(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE VALUES(10, '일반회원');
INSERT INTO USER_GRADE VALUES(20, '우수회원');
INSERT INTO USER_GRADE VALUES(30, '특별회원');

SELECT * FROM USER_GRADE;

CREATE TABLE USER_FOREIGNKEY(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT UF_GRAGE_FK FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE(GRADE_CODE)
);

INSERT INTO USER_FOREIGNKEY
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY
VALUES(2, 'user02', 'pass02', '남나눔', '남', '010-2222-3333', 'nam123@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY
VALUES(3, 'user03', 'pass02', '도대담', '남', '010-3333-4444', 'doh123@kh.or.kr', 30);

INSERT INTO USER_FOREIGNKEY
VALUES(4, 'user04', 'pass04', '류라라', '여', '010-4444-5555', 'ryu123@kh.or.kr', NULL);

SELECT * FROM USER_FOREIGNKEY;

INSERT INTO USER_FOREIGNKEY
VALUES(5, 'user05', 'pass05', '문미미', '여', '010-5555-6666', 'moon123@kh.or.kr', 50);
-- ORA-02291: integrity constraint (KH.UF_GRAGE_FK) violated - parent key not found

SELECT * FROM USER_GRADE;

-- 삭제 옵션
DELETE FROM USER_GRADE
WHERE GRADE_CODE = 10;
-- ORA-02292: integrity constraint (KH.UF_GRAGE_FK) violated - child record found

COMMIT;
-- 트랜젝션 : 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업 단위
-- COMMIT : 모든 작업을 정상적으로 처리하겠다고 확정하는 명령어
--          변경된 내용을 모두 영구 저장
--          COMMIT을 수행하면 하나의 트랜젝션 과정을 종료함
-- ROLLBACK : 작업 중 문제가 발생했을 때, 트랜젝션의 처리 과정에서 발생한 변경 사항(마지막 COMMIT)을 취소하고 트랜잭션 과정 종료

DELETE FROM USER_GRADE
WHERE GRADE_CODE = 20;

SELECT * FROM USER_GRADE;

ROLLBACK;

CREATE TABLE USER_GRADE2(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE2 VALUES(10, '일반회원');
INSERT INTO USER_GRADE2 VALUES(20, '우수회원');
INSERT INTO USER_GRADE2 VALUES(30, '특별회원');

CREATE TABLE USER_FOREIGNKEY2(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT UF_GRAGE_FK2 FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE2(GRADE_CODE) ON DELETE SET NULL
    -- 부모 키 삭제 시 자식 키를 NULL로 변경하는 옵션
);

INSERT INTO USER_FOREIGNKEY2
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY2
VALUES(2, 'user02', 'pass02', '남나눔', '남', '010-2222-3333', 'nam123@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY2
VALUES(3, 'user03', 'pass03', '도대담', '남', '010-3333-4444', 'doh123@kh.or.kr', 30);

INSERT INTO USER_FOREIGNKEY2
VALUES(4, 'user04', 'pass04', '류라라', '여', '010-4444-5555', 'ryu123@kh.or.kr', NULL);

INSERT INTO USER_FOREIGNKEY2
VALUES(5, 'user05', 'pass05', '문미미', '여', '010-5555-6666', 'moon123@kh.or.kr', 50);

COMMIT;

CREATE TABLE USER_GRADE3(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE3 VALUES(10, '일반회원');
INSERT INTO USER_GRADE3 VALUES(20, '우수회원');
INSERT INTO USER_GRADE3 VALUES(30, '특별회원');

CREATE TABLE USER_FOREIGNKEY3(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT UF_GRAGE_FK3 FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE3(GRADE_CODE) ON DELETE CASCADE
    -- 부모 키 삭제 시 연결된 자식 키를 삭제하는 옵션
);

INSERT INTO USER_FOREIGNKEY3
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY3
VALUES(2, 'user02', 'pass02', '남나눔', '남', '010-2222-3333', 'nam123@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY3
VALUES(3, 'user03', 'pass03', '도대담', '남', '010-3333-4444', 'doh123@kh.or.kr', 30);

INSERT INTO USER_FOREIGNKEY3
VALUES(4, 'user04', 'pass04', '류라라', '여', '010-4444-5555', 'ryu123@kh.or.kr', NULL);

INSERT INTO USER_FOREIGNKEY3
VALUES(5, 'user05', 'pass05', '문미미', '여', '010-5555-6666', 'moon123@kh.or.kr', 50);

COMMIT;

SELECT * FROM USER_GRADE3;
SELECT * FROM USER_FOREIGNKEY3;

DELETE FROM USER_GRADE3
WHERE GRADE_CODE = 10;

-- CHECK : 컬럼에 기록되는 값에 조건 설정
-- CHECK(컬럼명 비교연산자 비교값)
-- 비교 값은 리터럴만 사용 가능, 변하는 값이나 함수 사용 불가능

CREATE TABLE USER_CHECK(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10) CHECK(GENDER IN ('남', '여')),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50)
);

INSERT INTO USER_CHECK
VALUES(1, 'user01', 'pass01', '강건강', '남', '010-1111-2222', 'kang123@kh.or.kr');

INSERT INTO USER_FOREIGNKEY3
VALUES(2, 'user02', 'pass02', '남나눔', '남자', '010-2222-3333', 'nam123@kh.or.kr');

CREATE TABLE USER_CHECK2(
    TEST_NUMBER NUMBER,
    CONSTRAINT UC_TN_CK CHECK(TEST_NUMBER > 0)
);

INSERT INTO USER_CHECK2
VALUES(10);

INSERT INTO USER_CHECK2
VALUES(-10);

CREATE TABLE USER_CHECK3(
    C_NAME VARCHAR2(15 CHAR), -- 15글자 크기
    C_PRICE NUMBER,
    C_LEVEL CHAR(1),
    C_DATE DATE,
    CONSTRAINT UC3_CN_PK PRIMARY KEY(C_NAME),
--    CONSTRAINT UC3_CP_CK CHECK(C_PRICE >= 1 AND C_PRICE <= 99999)
    CONSTRAINT UC3_CP_CK CHECK(C_PRICE BETWEEN 1 AND 99999),
    CONSTRAINT UC3_CL_CK CHECK(C_LEVEL = 'A' OR C_LEVEL = 'C'),
    CONSTRAINT UC3_CD_CK CHECK(C_DATE >= TO_DATE('2016/01/01', 'YYYY/MM/DD'))
);

-- [실습 문제]
-- 회원가입용 테이블 생성(USER_TEST)
-- 컬럼명 : USER_NO(회원번호) - 기본키(PK_USER_NO), 
--         USER_ID(회원아이디) - 중복금지(UK_USER_ID),
--         USER_PWD(회원비밀번호) - NULL값 허용안함(NN_USER_PWD),
--         PNO(주민등록번호) - 중복금지(UK_PNO), NULL 허용안함(NN_PNO),
--         GENDER(성별) - '남' 혹은 '여'로 입력(CK_GENDER),
--         PHONE(연락처),
--         ADDRESS(주소),
--         STATUS(탈퇴여부) - NOT NULL(NN_STATUS), 'Y' 혹은 'N'으로 입력(CK_STATUS)
-- 각 컬럼의 제약조건에 이름 부여할 것
-- 5명 이상 INSERT할 것
CREATE TABLE USER_TEST(
    USER_NO NUMBER CONSTRAINT PK_USER_NO PRIMARY KEY,
    USER_ID VARCHAR2(20) CONSTRAINT UK_USER_ID UNIQUE,
    USER_PWD VARCHAR2(20) CONSTRAINT NN_USER_PWD NOT NULL,
    PNO VARCHAR2(30) CONSTRAINT UK_PNO UNIQUE CONSTRAINT NN_PNO NOT NULL,
    GENDER VARCHAR2(10) CONSTRAINT CK_GENDER CHECK(GENDER IN ('남', '여')),
    PHONE VARCHAR2(30),
    ADDRESS VARCHAR2(50),
    STATUS CHAR(1) CONSTRAINT NN_STATUS NOT NULL CONSTRAINT CK_STATUS CHECK(STATUS IN('Y', 'N'))
);

INSERT INTO USER_TEST
VALUES(1, 'user01', 'pass01', '621235-1985634', '남', '010-1111-2222', 'kang123@kh.or.kr', 'Y');

INSERT INTO USER_TEST
VALUES(2, 'user02', 'pass02', '861015-1356452', '남', '010-2222-3333', 'nam123@kh.or.kr', 'N');

INSERT INTO USER_TEST
VALUES(3, 'user03', 'pass03', '631010-1653546', '남', '010-3333-4444', 'doh123@kh.or.kr', 'N');

INSERT INTO USER_TEST
VALUES(4, 'user04', 'pass04', '770102-2357951', '여', '010-4444-5555', 'ryu123@kh.or.kr', 'Y');

INSERT INTO USER_TEST
VALUES(5, 'user05', 'pass05', '770808-2665412', '여', '010-5555-6666', 'moon123@kh.or.kr', 'Y');

-- SUBQUERY를 이용한 테이블 생성
CREATE TABLE EMPLOYEE_COPY
AS
SELECT * FROM EMPLOYEE;

SELECT * FROM EMPLOYEE_COPY;

CREATE TABLE EMPLOYEE_COPY2
AS
SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE
     LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
     JOIN JOB USING(JOB_CODE);
     
SELECT * FROM EMPLOYEE_COPY2;

-- 제약조건 추가
-- ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
-- ALTER TABLE 테이블명 ADD FOREIGN KEY(컬럼명) REFERENCES 테이블명(컬럼명)
-- ALTER TABLE 테이블명 ADD UNIQUE(컬럼명)
-- ALTER TABLE 테이블명 ADD CHECK(컬럼명)
-- ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL
CREATE TABLE USER_GRADE4(
    GRADE_CODE NUMBER,
    GRADE_NAME VARCHAR2(30)
);

ALTER TABLE USER_GRADE4 ADD PRIMARY KEY(GRADE_CODE);

CREATE TABLE USER_FOREIGNKEY4(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20), -- UNIQUE
    USER_PWD VARCHAR2(20), -- NOT NULL
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10), -- CHECK
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER -- FOREIGN KEY
);

ALTER TABLE USER_FOREIGNKEY4 ADD UNIQUE(USER_ID);
ALTER TABLE USER_FOREIGNKEY4 MODIFY USER_PWD NOT NULL;
ALTER TABLE USER_FOREIGNKEY4 ADD CHECK(GENDER IN('남', '여'));
ALTER TABLE USER_FOREIGNKEY4 ADD FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE4;

-- DEPARTMENT테이블의 LOACTION_ID에 외래키 제약조건 추가
-- 참조 테이블은 LOCATION, 참조 컬럼은 LOCATION의 기본키
ALTER TABLE DEPARTMENT ADD FOREIGN KEY(LOCATION_ID) REFERENCES LOCATION;


